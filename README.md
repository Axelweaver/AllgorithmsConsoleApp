# АЛГОРИТМЫ

### Определение Алгоритма


**Алгоритм** - Это конечная совокупность точно заданных правил решения некоторого произвольного класса задач или набора инструкций, описывающих порядок действий исполнителя для решения некоторой задачи.

#### Свойства алгоритма

- **Дискретность** - совокупность простых шагов

- **Детерменированность** - в каждый момент времени следующий шаг определяет состояние системы

- **Доступность/понятность**

- **Конечность**

- **Массовость** - алгоритм может быть применён к разным наборам данных

- **Результативность**

### Виды алгоритмов

- **Механические алгоритмы** - жёсткие, детерменированные, задают действие в определённой последовательности
- **Гибкие алгоритмы** - вероятностные и эвристические
- **Вероятностный** - несколько путей и способов, приводящих к вероятному решению задачи
- **Эвристический** - использует утверждение без обоснования
- **Линейный алгоритм** - есть структура
- **Циклический алгоритм** - есть циклы
- **Вспомогательный алгоритм** - подалгоритм внутри алгоритма


### Сложность алгоритма

**При разработке алгоритма очень важно быть способным оценить ресурсы, необходимые для приведения вычислений**

#### Нотация асимптотического роста

| Обозначение | Граница| Рост |
| ----- | ----- | ---- |
| **Θ** (тэта) | Нижняя и верхняя границы, точная оценка | Равно ( = )  |
| **O** (большое) | Верхняя граница, точная оценка неизвестна | Меньше или равно ( ≤ )  |
| **o** (малое) | Верхняя граница, неточная оценка | Меньше ( < ) |
| **Ω** (омега большое) | Нижняя граница, точная оценка неизвестна | Больше или равно ( ≥ )  |
| **ω** (омега малое) | Нижняя граница, неточная оценка  | Больше ( > ) |


| Алгоритм | Эффектиность |
| ----- | ---- |
| **o (n)** |  < n |
| **O (n)** | ≤ n |
| **Θ (n)** | = n |
| **Ω (n)** | ≥ n |
| **ω (n)** | > n |

### O - нотация сложности алгоритмов

О - нотация (от немецкого "Ordung") - O (f(x)) - формула, выражающая сложность алгоритма. Для оценки сложности алгоритмов по времени или по памяти используется понятие "О большое".

#### Виды сложности алгоритмов в О-нотации

- **Константный O(1)** - нет зависимости от размера входных данных

- **Линейный O(n)** - Сложность алгоритма растёт линейно с увеличением данных. Если 1 элемент обрабатывается за 1 секунду, то 60 элементов обработается за 1 минуту. Такие алгоритмы легко узнать по наличию цикла внутри алгоритма

- **Логарифмический O(log(n))** - где n = 2 по умолчанию. Это алгоритмы, использующие принцип золотого сечения 

- **Линеарифметический O(n- log(n))** - разновидность алгоритмов, работающих по принципу "разделяй и властвуй"

- **Квадратичный O(n²)** - обычно это реализация алгоритма с двумя вложенными циклами, один внутри другого. Таким образом, количество операций будет зависеть он n * n, т.е. n². 

#### График сложности алгоритмов в О-нотации

![График сложности алгоритмов](/img/bigOcomplexityChart.png)

### Алогоритмы сортировки

#### Пузырьковая сортировка (Bubble sort)

Или **сортировка простыми обменами**. Принцип действия прост: обходимо массив от начала до конца, попутно меняя местами неотсортированные соседние элементы. В результате первого прохода на последнее место "всплывёт" максимальный элемент. Затем нужно снова обойти неотсортированную часть массива (от первого до последнего элементов). Сложность такого алгоритма всегда **O(n2)**

В коде этого репозитория это класс [BubbleSorting](/Sorting/BubbleSorting.cs)

```csharp
    internal class BubbleSorting
    {
        public static int[] DescendingSort(int[] array)
        {
            Console.WriteLine("Bubble sort");

            int temp;
            for(var i = 0; i < array.Length - 1; i++)
            {
                for(var j = 0; j < array.Length - i - 1; j++)
                {
                    if (array[j + 1] > array[j])
                    {
                        temp = array[j + 1];
                        array[j + 1] = array[j];
                        array[j] = temp;
                    }
                }
            }

            return array;
        }
    }
```

#### Шейкерная сортировка (Shaker Sort)

Она же **сортировка перемешиванием**, она же **коктейльная сортировка**. По идее, это разновидность пузырьковой сортировки.
Начинается процесс как в «пузырьке»: выдавливаем максимум на самые задворки. После этого разворачиваемся на 180° и идём в обратную сторону, при этом уже перекатывая в начало не максимум, а минимум. Отсортировав в массиве первый и последний элементы, снова делаем кульбит. Обойдя туда-обратно несколько раз, в итоге заканчиваем процесс, оказавшись в середине списка.
Шейкерная сортировка работает немного быстрее чем пузырьковая, поскольку по массиву в нужных направлениях попеременно мигрируют и максимумы и минимумы. Сложность такого алгоритма в лучшем случае O(n), в среднем и худшем - O(n)²

В коде репозитория это класс [ShakerSorting](/Sorting/ShakerSorting.cs)

```csharp
    internal class ShakerSorting
    {
        public static int[] Sort(int[] array)
        {
            Console.WriteLine("Shake sorting");

            int left = 0,
                right = array.Length - 1,
                count = 0;

            while (left < right)
            {
                for (int i = left; i < right; i++)
                {
                    count++;
                    if (array[i] > array[i + 1])
                    {
                        array.Swap(i, i + 1);
                    }
                }
                right--;

                for (int i = right; i > left; i--)
                {
                    count++;
                    if (array[i - 1] > array[i])
                    {
                        array.Swap(i - 1, i);
                    }
                }
                left++;
            }

            return array;
        }
    }
```

#### Сортировка расчёской (Combo Sort)

В «пузырьке», «шейкере» при переборе массива сравниваются соседние элементы. Основная идея «расчёски» в том, чтобы первоначально брать достаточно большое расстояние между сравниваемыми элементами и по мере упорядочивания массива сужать это расстояние вплоть до минимального. Таким образом мы как бы причёсываем массив, постепенно разглаживая на всё более аккуратные пряди.

Первоначальный разрыв между сравниваемыми элементами лучше брать не абы какой, а с учётом специальной величины называемой фактором уменьшения, оптимальное значение которой равно примерно 1,247. Сначала расстояние между элементами равно размеру массива разделённого на фактор уменьшения (результат, естественно, округляется до ближайшего целого). Затем, пройдя массив с этим шагом, мы снова делим шаг на фактор уменьшения и проходим по списку вновь. Так продолжается до тех пор, пока разность индексов не достигнет единицы. В этом случае массив досортировывается обычным пузырьком.

Опытным и теоретическим путём установлено оптимальное значение фактора уменьшения:

![фактор уменьшения](/img/minfactor.png)

Сложность такого алгоритма в лучшем случае O(n log n), в худшем - O(n)²

В коде репозитория это класс [ComboSorting](/Sorting/ComboSorting.cs)

```csharp
	internal class ComboSorting
	{
		public static int[] Sort(int[] array)
		{
			Console.WriteLine("Combo sorting");

			double gap = array.Length;
			bool swaps = true;
			while (gap > 1 || swaps)
			{
				gap /= 1.247330950103979;
				if (gap < 1)
				{
					gap = 1;
				}
				int i = 0;
				swaps = false;
				while (i + gap < array.Length)
				{
					int igap = i + (int)gap;
					if (array[i] > array[igap])
					{
						int swap = array[i];
						array[i] = array[igap];
						array[igap] = swap;
						swaps = true;
					}
					i++;
				}
			}
			return array;
		}
	}
```

#### Сортировка вставками (Insertion Sort)

Это алгоритм сортировки, в котором элементы входной последовательности просматриваются по одному, и каждый новый элемент размещается в подходящее место среди ранее упорядоченных элементов.

Сложность такого алгоритма в лучшем случае O(n), в среднем и худшем - O(n²)

В коде репозитория это класс [InsertionSorting](/Sorting/InsertionSorting.cs)

```csharp
    internal class InsertionSorting
    {
        public static int[] Sort(int[] array)
        {
            Console.WriteLine("Insertions sort");

            for (int i = 1; i < array.Length; i++)
            {
                int current = array[i];
                int j = i;
                while (j > 0 && current < array[j - 1])
                {
                    array[j] = array[j - 1];
                    j--;
                }
                array[j] = current;
            }

            return array;
        }
    }
```
#### Сортировка выбором (Selection Sort)
Может быть как устойчивый, так и неустойчивый. На массиве из n элементов имеет время выполнения в худшем, среднем и лучшем случае O(n²), предполагая что сравнения делаются за постоянное время.
Шаги алгоритма:

1. Находим номер минимального значения в текущем списке.
2. Производим обмен этого значения со значением первой неотсортированной позиции (обмен не нужен, если минимальный элемент уже находится на данной позиции).
3. Теперь сортируем хвост списка, исключив из рассмотрения уже отсортированные элементы.

В коде репозитория это класс [SelectionSorting](/Sorting/SelectionSorting.cs)

```csharp
    internal class SelectionSorting
    {
        public static int[] Sort(int[] array)
        {
            for (int i = 0; i < array.Length; ++i)
            {
                var minIndex = i;
                for (int j = i + 1; j < array.Length; ++j)
                {
                    if(array[j] < array[minIndex]) 
                    { 
                        minIndex = j;
                    }
                }
                if (minIndex != i)
                {
                    array.Swap(i, minIndex);
                }
            }

            return array;
        }
    }
```

#### Сортировка Шелла (Shell Sort)

Сортировка Шелла - алгоритм сортировки, являющийся усовершенствованным вариантом сортировки вставками. Идея метода Шелла состоит в сравнении элементов, стоящих не только рядом, но и на определённом расстоянии друг от друга. Иными словами - это сортировка вставками с предварительными грубыми проходами. Аналогичный метод усовершенствования пузырьковой сортировки называется Сортировка расчёской.
При сортировке Шелла сначала сравниваются и сортируются между собой значения, стоящие один от другого на некотором расстоянии d. После этого процедура повторяется для некоторых меньших значений d, а завершается сортировка упорядоиванием элементов при d = 1. Эффективность сортировки Шелла в определённых случаях обеспечивается тем, что элементы "быстрее" встают на свои места (в простых методах сортировки, например пузырьковой, каждая перестановка элементов уменьшает количество инверсий в списке максимум на 1, а при сортировке Шелла это число может быть больше)

В коде репозитория это класс [ShellSorting](/Sorting/ShellSorting.cs)

```csharp
    internal class ShellSorting
    {
        public static int[] Sort(int[] array)
        {
            for (int s = array.Length / 2; s > 0; s /= 2)
            {
                for (int i = s; i < array.Length; ++i)
                {
                    for (int j = i - s; j >= 0 && array[j] > array[j + s]; j -= s)
                    {
                        int temp = array[j];
                        array[j] = array[j + s];
                        array[j + s] = temp;
                    }
                }
            }

            return array;
        }
    }
```


#### Быстрая сортировка (Quick Sort)

Быстрая сортировка или сортировка Хоара, часто называемая qsort (по имени библиотеки) - алгоритм сортировки, разработанный английским инфморматиком Тони Хоаром в 1960 году.
Один из самых быстрых известных универсальных алгоритмов сортировки массивов, со сложностью в среднем O(n log n) обменов при упорядочении n элементов.
QuickSort является существенно улучшенным вариантом алгоритма сортировки с помощью прямого обмена (его варианты известны как «Пузырьковая сортировка» и «Шейкерная сортировка»), известного в том числе своей низкой эффективностью. Принципиальное отличие состоит в том, что в первую очередь производятся перестановки на наибольшем возможном расстоянии и после каждого прохода элементы делятся на две независимые группы (таким образом улучшение самого неэффективного прямого метода сортировки дало в результате один из наиболее эффективных улучшенных методов).

Общая идея алгоритма состоит в следующем:

Выбрать из массива элемент, называемый опорным. Это может быть любой из элементов массива. От выбора опорного элемента не зависит корректность алгоритма, но в отдельных случаях может сильно зависеть его эффективность (см. ниже).
Сравнить все остальные элементы с опорным и переставить их в массиве так, чтобы разбить массив на три непрерывных отрезка, следующих друг за другом: «элементы меньшие опорного», «равные» и «большие».
Для отрезков «меньших» и «больших» значений выполнить рекурсивно ту же последовательность операций, если длина отрезка больше единицы.

В коде репозитория это класс [QuickSorting](/Sorting/QuickSorting.cs)

```csharp
    public static class QuickSorting
    {
        public static int[] Sort(int[] array)
        {
            return SortArray(array, 0, array.Length - 1);
        }

        private static int[] SortArray(int[] array, int leftIndex, int rightIndex)
        {
            var i = leftIndex;
            var j = rightIndex;
            var pivot = array[leftIndex];

            while (i <= j)
            {
                while (array[i] < pivot)
                {
                    i++;
                }

                while (array[j] > pivot)
                {
                    j--;
                }

                if (i <= j)
                {
                    int temp = array[i];
                    array[i] = array[j];
                    array[j] = temp;
                    i++;
                    j--;
                }
            }

            if (leftIndex < j)
                SortArray(array, leftIndex, j);

            if (i < rightIndex)
                SortArray(array, i, rightIndex);

            return array;
        }
    }
```

